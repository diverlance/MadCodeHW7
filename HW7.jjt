/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  IGNORE_CASE=true;
    JJTREE_OUTPUT_DIRECTORY="src/wci/frontend";
    NODE_EXTENDS="wci.intermediate.icodeimpl.ICodeNodeImpl";
    MULTI=true;
    VISITOR=true;
}

PARSER_BEGIN(HtScrape)
package wci.frontend;

import java.util.ArrayList;
import java.io.*;

import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.backend.*;
import wci.util.*;
 
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class HtScrape
{
    private static final String SOURCE_SUFFIX = ".txt";
    private static final String OUTPUT_SUFFIX = ".j";

    private static SymTabStack symTabStack;
    private static SymTabEntry programId;

    private static ArrayList<SymTabEntry> variableList = new ArrayList<SymTabEntry>();
    private static int variableIndex = 0;
    
  public static void main(String args [])
  	throws Exception
  {
    	// Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);

        // Process the source file path which ends in .pcl
        // and create the output file path which ends in .j
        String sourceFilePath = "input.txt";
        int truncatedLength = sourceFilePath.length() - SOURCE_SUFFIX.length();
        int suffixIndex = sourceFilePath.lastIndexOf(SOURCE_SUFFIX);
        String objectFilePath = (suffixIndex == truncatedLength)
            ? sourceFilePath.substring(0, truncatedLength) + OUTPUT_SUFFIX
            : sourceFilePath + OUTPUT_SUFFIX;

        // Parse a HtScrape program.
        Reader    reader = new FileReader(sourceFilePath);
        HtScrape parser = new HtScrape(reader);
        SimpleNode rootNode = parser.Program();

    // Print the cross-reference table
    CrossReferencer crossReferencer = new CrossReferencer();
    crossReferencer.print(symTabStack);

        // Visit the parse tree nodes to decorate them with type information.
        TypeSetterVisitor typeVisitor = new TypeSetterVisitor();
        rootNode.jjtAccept(typeVisitor, null);

        // Create and initialize the ICode wrapper for the parse tree.
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);
        
    // Print the parse tree
    ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
    treePrinter.print(symTabStack);
  }
}

PARSER_END(HtScrape)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      ~[ "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

/*TOKEN : //LITERALS 
{
  < INTEGER_LITERAL :
    < DECIMAL_LITERAL > ([ "l", "L" ])?
  | < HEX_LITERAL > ([ "l", "L" ])?
  | < OCTAL_LITERAL > ([ "l", "L" ])? 
    >
| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >
| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >
| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
}*/

/*TOKEN :  IDENTIFIERS
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >
| < #DIGIT : [ "0"-"9" ] >
} */

TOKEN: /*HtScrape Tokens */
{
  	<STRING_LITERAL:"\"" (~["\n","\r","\""])* ("\""|"\n"|"\r"|"\r\n")>
  	{ debugStream.println("STRING_LITERAL token: " + matchedToken.image); }
 	| 
    <CHARACTER:
    "'"(["a"-"z", "A"-"Z", "_"]|"\\"|["0"-"9"])"'"
    >  { debugStream.println("CHARACTER token: " + matchedToken.image); }
    |
    <DIGIT:
    ["0"-"9"]
    >
  	| //reserved words
    <IF: "if" >
    { debugStream.println("IF token: " + matchedToken.image); }
    |
    <ELSE: "else" >
    { debugStream.println("ELSE token: " + matchedToken.image); }
    |
    < THEN: "then" >
    { debugStream.println("THEN token: " + matchedToken.image); }
    | 
    <EXIT: "exit" >
    { debugStream.println("EXIT token: " + matchedToken.image); }
    |
    < THROW: "throw" >
    { debugStream.println("THROW token: " + matchedToken.image); }
    | 
    < BREAK: "break" >
    { debugStream.println("BREAK token: " + matchedToken.image); }
    |
    < VOID: "void" >
    { debugStream.println("VOID token: " + matchedToken.image); }
    |
    < RETURN: "return" >
    { debugStream.println("RETURN token: " + matchedToken.image); }
    |
    < INT: "int" >
    { debugStream.println("INT token: " + matchedToken.image); }
    |
    < NUMBER: "number" >
    { debugStream.println("NUMBER token: " + matchedToken.image); }
  	|
  	< STRING: "string">
  	{ debugStream.println("STRING token: " + matchedToken.image); }
 	| 
    < TRUE: "true" >
    { debugStream.println("TRUE token: " + matchedToken.image); }
    |
    < FALSE: "false" >
    { debugStream.println("FALSE token: " + matchedToken.image); }
    | 
    < TRY: "try" >
    { debugStream.println("TRY token: " + matchedToken.image); }
    |
    < CATCH: "catch" >
    { debugStream.println("CATCH token: " + matchedToken.image); }
    |
    < FOR: "for" >
    { debugStream.println("FOR token: " + matchedToken.image); }
    |
    < NULL: "null" >
    { debugStream.println("NULL token: " + matchedToken.image); }
    |
    < TABLE: "table" >
    { debugStream.println("TABLE token: " + matchedToken.image); }
    |
    < TABLE_DATA: "table_data" >
    { debugStream.println("TABLE_DATA token: " + matchedToken.image); }
    |
    < COLOR: "color" >
    { debugStream.println("COLOR token: " + matchedToken.image); }
  	| 
    < GET: "get" >
    { debugStream.println("GET token: " + matchedToken.image); }
    |
    < PRINT: "print" >
    { debugStream.println("PRINT token: " + matchedToken.image); }
    |
    < CLOSE: "close" >
	{ debugStream.println("CLOSE token: " + matchedToken.image); }
 	|
 	< FILE: "file" >
    { debugStream.println("FILE token: " + matchedToken.image); }
    |
    < LOAD: "load" >
	{ debugStream.println("LOAD token: " + matchedToken.image); }
 	|
 	< GET_TABLE: "getTable" >
	{ debugStream.println("GET_TABLE token: " + matchedToken.image); }
 	|
 	< GET_DATA: "getData" >
	{ debugStream.println("GET_DATA token: " + matchedToken.image); }
 	|
 	< GET_COLOR: "getColor" >
	{ debugStream.println("GET_COLOR token: " + matchedToken.image); }
 	|  
    <IDENTIFIER: (["a"-"z", "A"-"Z"])(["a"-"z", "A"-"Z", "0"-"9","_", "-"])* >  
   	{ debugStream.println("IDENTIFIER token: " + matchedToken.image); }
    |
	// SPECIAL SYMBOLS
    < LEFT_PAREN: "(" >
    { debugStream.println("LEFT_PAREN token: " + matchedToken.image); }
  	|
  	< RIGHT_PAREN: ")" >
  	{ debugStream.println("RIGHT_PAREN token: " + matchedToken.image); }
 	|
 	< LEFT_CURLY: "{" >
	{ debugStream.println("LEFT_CURLY token: " + matchedToken.image); }
	| 
 	< RIGHT_CURLY: "}" >
	{ debugStream.println("RIGHT_CURLY token: " + matchedToken.image); }
	| 
	< PLUS: "+" >
 	{ debugStream.println("PLUS token: " + matchedToken.image); }
	|
	< MINUS: "-" >
 	{ debugStream.println("MINUS token: " + matchedToken.image); }
	|
 	< EQUALS: "=" >
 	{ debugStream.println("EQUALS token: " + matchedToken.image); }
	|
	< LESS_THAN: "<" >
	{ debugStream.println("LESS_THAN token: " + matchedToken.image); }
	|
	< GREATER_THAN: ">" >
	{ debugStream.println("GREATER_THAN token: " + matchedToken.image); }
	|
	< BANG: "!" >
	{ debugStream.println("BANG token: " + matchedToken.image); }
	|
	< COMMA: "," >
	{ debugStream.println("COMMA token: " + matchedToken.image); }
	|
	< PERIOD: "." >
	{ debugStream.println("PERIOD token: " + matchedToken.image); }
	|
	< SEMICOLON: ";" >
	{ debugStream.println("SEMICOLON token: " + matchedToken.image); }
	|
	< AT_SIGN: "@" >
	{ debugStream.println("AT_SIGN token: " + matchedToken.image); }
	|
	< POUND_SIGN: "#" >
	{ debugStream.println("POUND_SIGN token: " + matchedToken.image); }
}

	//production rules
	SimpleNode Program(): {SimpleNode rootNode;}
	{
	  {
	    programId = symTabStack.enterLocal("Prorgam");
        programId.setDefinition(DefinitionImpl.PROGRAM);
        programId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
        symTabStack.setProgramId(programId);	  }
	   try {
        
        //(Statement())+
        rootNode = Statement()
        
        <EOF> {
          System.out.println("\n** Successfully parsed an entire Program!\n");
           return rootNode;
        }
    }
    catch (ParseException ex) {
        handleError(ex);
        return null;
    }
	  	
} 
 
	
	SimpleNode Statement() : {}
	{
	  (
	    IntDeclaration() |
	    StringDeclaration() |
	    SimpleAssignment() |
	    FileDeclaration() |
	    LoadStatement() |
	    TableDeclaration() |
	    GetTableStatement() |
	    TableDataDeclaration() |
	    GetTableDataStatement() |
	    ColorDeclaration() |
	    GetColorStatement() |
	    PrintStatement() |
	    CloseStatement() |
	    IfStatement()
	  )*
	  {	    return jjtThis;	  }	  
	}

	void variable() : {}
{
    <IDENTIFIER> {
        SymTabEntry variableId = symTabStack.lookup(token.image);
        variableId.appendLineNumber(token.beginLine);
        TypeSpec type = variableId.getTypeSpec();
        jjtThis.setTypeSpec(type);
        jjtThis.setAttribute(ID, variableId);
    }
}

	void newVariable(TypeSpec type) : {}
	{		<IDENTIFIER>
		 {		   processVariableDecl(token, variableIndex++, variableList);
		   variableList.get(variableIndex-1).setTypeSpec(type);
		   jjtThis.setTypeSpec(type);
		   jjtThis.setAttribute(ID, token);
		 }
	}

	void IntDeclaration(): {}
	{
	  < INT >
	  {
          SymTabEntry typeId = symTabStack.lookup(token.image);
          typeId.appendLineNumber(token.beginLine);
          TypeSpec type = typeId.getTypeSpec(); 	  }
	  newVariable(type)
	  < EQUALS >
      integerConstant()
	  < SEMICOLON >
	  {
	    System.out.println("Successfully parsed an Int Declaration!\n");
	  }
	}


	
	void SimpleAssignment() : {}
	{
	  variable()
	  < EQUALS >
	  (integerConstant()
      |
      stringConstant()
      )
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a Simple Assignment!\n"); }
	}

	void StringDeclaration() : {}
	{
	  < STRING >
	  {
        SymTabEntry typeId = symTabStack.lookup(token.image);
        typeId.appendLineNumber(token.beginLine);
        TypeSpec type = typeId.getTypeSpec(); 
	  }
	  newVariable(type)
	  < EQUALS >
	  stringConstant()
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a String Declaration!\n"); }
	}

	void FileDeclaration() : {}
	{
	  < FILE >
	  {
        SymTabEntry typeId = symTabStack.lookup(token.image);
        typeId.appendLineNumber(token.beginLine);
        TypeSpec type = typeId.getTypeSpec(); 
	  }	  
	   newVariable(type)
	  < EQUALS >
	  LoadStatement()
	  { System.out.println("Successfully parsed a File Declaration!\n"); }
	}

	void LoadStatement() : {}
	{
	  < LOAD >
	  < LEFT_PAREN >
	  variable()
	  < RIGHT_PAREN >
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a Load Statement!\n"); }
	}

	void TableDeclaration(): {}
	{
	  < TABLE >
	  {
        SymTabEntry typeId = symTabStack.lookup(token.image);
        typeId.appendLineNumber(token.beginLine);
        TypeSpec type = typeId.getTypeSpec(); 
	  }	  
	   newVariable(type)
	  < EQUALS >
	  GetTableStatement()
	  { System.out.println("Successfully parsed a Table Declaration!\n"); }
	}

	void GetTableStatement(): {}
	{
	  < GET_TABLE >
	  < LEFT_PAREN >
	  variable()
	  < RIGHT_PAREN >
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a GetTable Statement!\n"); }
	}

	void TableDataDeclaration(): {}
	{
	  < TABLE_DATA >
	  {
        SymTabEntry typeId = symTabStack.lookup(token.image);
        typeId.appendLineNumber(token.beginLine);
        TypeSpec type = typeId.getTypeSpec(); 
	  }	  
	   newVariable(type)
	  < EQUALS >
	  GetTableDataStatement()
	  { System.out.println("Successfully parsed a TableData Declaration!\n"); }
	}

	void GetTableDataStatement(): {}
	{
	  < GET_DATA >
	  < LEFT_PAREN >
	  MultipleParams()
	  < RIGHT_PAREN >
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a GetTableData Statement!\n"); }
	}

	void ColorDeclaration(): {}
	{
	  < COLOR >
	  {
        SymTabEntry typeId = symTabStack.lookup(token.image);
        typeId.appendLineNumber(token.beginLine);
        TypeSpec type = typeId.getTypeSpec(); 
	  }	  
	   newVariable(type)
	  < EQUALS >
	  GetColorStatement()
	  { System.out.println("Successfully parsed a Color Declaration!\n"); }
	}

	void GetColorStatement(): {}
	{
	  < GET_COLOR >
	  < LEFT_PAREN >
	  MultipleParams()
	  < RIGHT_PAREN >
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a GetColor Statement!\n"); }
	}
	
	void MultipleParams() : {}
	{
	  (< IDENTIFIER >|(< DIGIT >)+)
	  (
	    < COMMA >
	    (
	      < IDENTIFIER >|(< DIGIT >)+)
	  )*
	  { System.out.println("Successfully parsed multiple parameters!\n"); }
	}

	void PrintStatement() : {}
	{
	  < PRINT >
	  < LEFT_PAREN >
	  variable()
	  < RIGHT_PAREN >
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a Print Statement!\n"); }
	}

	void CloseStatement() : {}
	{
	  < CLOSE >
	  < LEFT_PAREN >
	  variable()
	  < RIGHT_PAREN >
	  < SEMICOLON >
	  { System.out.println("Successfully parsed a Close Statement!\n"); }
	}
	
    void IfStatement() : {} {
  		<IF><LEFT_PAREN>
  		Expression()
  		<RIGHT_PAREN><LEFT_CURLY >
  		Statement()
  		<RIGHT_CURLY >
    	{ System.out.println("Successfully parsed an if statement!\n"); }
	}
	
	void Expression() : {} 
	{
  		{System.out.println("\nEXPRESSION STARTS");}
  		Operator()
  		{System.out.println("EXPRESSION ENDS\n");}
	}

	void Operator() : {} 
	{
  		<IDENTIFIER> 
  		expr_operator()  
  		Operand()
	}
	
	void Operand() : {Token t;} 
	{
 		 t=<DIGIT> {System.out.println("Operand: " + t.image);}
	}

	void expr_operator() :{Token t;	}
	{
	  {System.out.println("Operator:");}
	  (< PLUS >|< MINUS >|< EQUALS >|< GREATER_THAN >|< LESS_THAN >)
	}

	void integerConstant() : {}
	{
    <DIGIT> {
        jjtThis.setTypeSpec(Predefined.integerType);
        jjtThis.setAttribute(VALUE, Integer.parseInt(token.image));
    	}
	}

	void stringConstant() : {}
	{
    <STRING_LITERAL> {
        jjtThis.setTypeSpec(Predefined.stringType);
        jjtThis.setAttribute(VALUE, String.valueOf(token.image));
    	}
	}
//Handles errors when parsing
/*JAVACODE 
public String errorHandler(ParseException exception) 
{
    Token token = exception.currentToken;
    System.out.println(ex.getMessage());
    do {token = getNextToken();} 
    while (token.kind != SEMICOLON);
    jjtThis.popNode();
    return token.image;
}*/
JAVACODE
void processVariableDecl(Token token, int index,
                         ArrayList<SymTabEntry> variableList) #void
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
    variableList.add(variableId);
}

JAVACODE
String handleError(ParseException ex) #void
{
    Token token = ex.currentToken;
    System.out.println(ex.getMessage());

    do {
    	token = getNextToken();
    } while (token.kind != SEMICOLON);

	jjtree.popNode();
    return token.image;
}